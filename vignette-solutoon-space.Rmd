---
title: "communities library - Rings of Cliques"
output:
  pdf_document: default
  html_notebook: default
vignette: >
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", fig.width = 6, fig.height = 4)
set.seed(123) # reproducibility for layouts only
suppressPackageStartupMessages({
  library(dplyr)
  library(tibble)
  library(igraph) 
})

library(tidyverse)
library(knitr)   # for kable()
library(igraph)
library(communities)
```

## Rings of cliques

This vignette shows how to create **Ring-of-Cliques (RC)**, a simple test-network, using `communities::make_ring_of_cliques()` with four variants:

-   **RC**
-   **RC_B** — ring bridges between adjacent cliques
-   **RC_C** — one central node connected to each clique
-   **RC_BC** — both ring bridges **and** central node

Each clique is a ground-truth community. The function annotates vertices with:

-   `gt_community` (numeric),

-   `gt_label` (character),

-   `clique_id`, `within_id`,

-   role flags (`role`, `is_bridge_endpoint`, `is_center_endpoint`).

Graphs are constructed deterministically: all clique vertices come first, the optional center (if any) is last.

------------------------------------------------------------------------

```{r}

g  <- communities::make_ring_of_cliques(
    n_cliques = 5,
    clique_size = 5,
    variant = "RC+BC"
)

plot(
  g,
  vertex.color = degree(g),
  vertex.label = NA,
  vertex.size = 15,
  edge.color = "grey70",
)
 
 
```

```{r}

ssp <- communities::solutions_space_DM(g, 
                                       verbose = FALSE, 
                                       met = "LV")
cat(
    sprintf(
        "The solution space exploration stopped after %d trials due to '%s'. ",
        ssp$log$stop_trial,
        ssp$log$stop_reason
    )
)

cat(
    sprintf(
        "It was run with confidence level %.3f, and a maximum CI width of %.3f. ",
        ssp$log$confidence,
        max(ssp$log$max_ci_width)
    )
)

cat(
    sprintf(
        "The counts were recorded both in long format (%d rows) and in matrix format (%d × %d).",
        nrow(ssp$log$counts_long),
        nrow(ssp$log$counts_matrix),
        ncol(ssp$log$counts_matrix)
    )
)


```
```{r}
communities::solution_space_type(ssp)
```

# use solution space to singal outliers

```{r}
 
signal_outliers <- function(graph,
                            D,
                            method = c("quantile", "mad", "fixed"),
                            alpha = 0.05,
                            k = 3,
                            threshold = 0.5) {
  method <- match.arg(method)

  # --- Align D to graph order if names are available 
  n <- igraph::vcount(graph)
  if (!is.matrix(D) || nrow(D) != ncol(D)) stop("`D` must be a square matrix.")
  if (!is.null(rownames(D)) && !is.null(igraph::V(graph)$name)) {
    idx <- match(igraph::V(graph)$name, rownames(D))
    if (any(is.na(idx))) stop("Vertex names of `graph` do not match rownames of `D`.")
    D <- D[idx, idx, drop = FALSE]
  } else if (nrow(D) != n) {
    stop("Size mismatch: number of vertices in `graph` must equal nrow(D).")
  }

  # --- Safety clamp to [0,1] and ignore diagonal in scoring -------------------
  D[!is.finite(D)] <- 0
  D[D < 0] <- 0; D[D > 1] <- 1
  diag(D) <- 0  # self-pairs excluded by definizione della media sui vicini

  # --- Adjacency (mask of neighbors) ------------------------------------------
  A <- as.matrix(igraph::as_adjacency_matrix(graph, sparse = FALSE))
  diag(A) <- 0
  deg <- rowSums(A)

  # --- Gamma: mean over neighbors; zeros kept for non-co-occurring neighbors --
  # Numeratore = somma D[v, u] su u vicini; Denominatore = grado (num. vicini)
  num <- rowSums(D * A)
  gamma <- ifelse(deg > 0, num / deg, 0)

  # --- Outlier rule ------------------------------------------------------------
  if (method == "quantile") {
    cut <- stats::quantile(gamma, probs = alpha, na.rm = TRUE)
    is_outlier <- gamma <= cut
  } else if (method == "mad") {
    med  <- stats::median(gamma, na.rm = TRUE)
    madv <- stats::mad(gamma, constant = 1.4826, na.rm = TRUE)
    score <- (med - gamma) / ifelse(madv > 0, madv, Inf)
    is_outlier <- score >= k
  } else { # fixed
    is_outlier <- gamma <= threshold
  }

  nm <- igraph::V(graph)$name
  if (is.null(nm)) nm <- as.character(seq_len(n))

  data.frame(
    node_id    = seq_len(n),
    name       = nm,
    degree     = deg,
    gamma      = gamma,
    is_outlier = as.logical(is_outlier),
    stringsAsFactors = FALSE
  )
}
 
```

```{r}
Gamma<-co_occurrence(ssp)
rownames(Gamma)
V(g)$name
outls <- signal_outliers(g, Gamma)
hist(outls$gamma)
gamma_vals <- outls$gamma
node_colors <- rgb(1 - gamma_vals, gamma_vals, 0)
 
plot(
  g,
  vertex.color = node_colors,
  vertex.size = 20,
  vertex.label = NA,
  main = "outliers a are highlighted in red"
)
# add a legend
legend(
  "topleft",
  legend = c("gamma = 0", "gamma = 1"),
  fill   = c("red", "green"),
  border = NA,
  bty    = "n",
  title  = "Gamma scale"
)

```

 

 

  
