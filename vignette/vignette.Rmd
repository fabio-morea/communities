
---
title: "Vignette: create a benchmark network and explore solution space"
author: "Fabio Morea"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{RIng of Cliques and solution space}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# scope
This vignette illustrates the complete workflow of 'communities' library.

```{r libraries, message=FALSE, warning=FALSE}
# required packages
library(igraph)
library(communities)

# additional packages to improve workflow and figures
library(tidyverse)
library(patchwork)
```


# Benchmark networks
We start by building a simple benchmark network: a Ring of Cliques (RC) composed of 5 cliques of 6 nodes each. In such a simple case communities are easily identified by any community detection algorithm.

```{r example1, message=FALSE, warning=FALSE}
RC_simple <- communities::make_ring_of_cliques(num_cliques = 5,
                                       clique_size = 5, 
                                       add_center = F, 
                                       add_bridges = F)
partition <- igraph::cluster_louvain(RC_simple)
plot(partition, RC_simple)
```

However, RC can be used to produce a network in which community boundaries are less clear. 

```{r example2, message=FALSE, warning=FALSE}
RC_c <- communities::make_ring_of_cliques(num_cliques = 4,
                                       clique_size = 6, 
                                       add_center = T, 
                                       add_bridges = F)

node_positions <- igraph::layout.fruchterman.reingold(RC_c)
partition <- igraph::cluster_louvain(RC_c)
plot(partition, RC_c, layout = node_positions)

```
The central node can either belong to any of the cliques or be considered its own single-node community. This presents a challenge for both algorithms and human analysts alike, as it creates ambiguity in community assignment. Consequently, we can anticipate five equally probable solutions, where the central node is equally likely to be associated with any of the cliques.

```{r example1, message=FALSE, warning=FALSE}
#explore the solution space
sol_space <- communities::solutions_space(RC_c, 
                                          n_trials = 100,
                                          met = "LV")
sol_space <- communities::quality_check(RC_c, sol_space)
plots<-communities::plot_sol_space(sol_space)
plots$pl2
plots$pl3
```

```{r}

communities::plot_all_solutions(RC_c, sol_space)   

communities::plot_all_solutions(RC_c, sol_space, 
               device = "png", 
               filename = ".\solution_plots.png")
```

 
 


The solution space shows that there are 6 solutions, they are all equally likely (the confidence intervals are overlapping).

## input ordering bias
In the example above, the network was shuffled before each run of the community detection algorithm to help mitigate input ordering bias. To highlight the importance of this, we can repeat the experiment with the 'shuffle' parameter set to FALSE. In this case, community detection will be performed on the network exactly as it was provided, which is influenced by the order in which nodes and edges are sorted in the original data. Although in theory this should not impact the results (since graphs are inherently unordered mathematical objects), it does. This is because the software representation of networks is inherently orderedâ€”whether in the form of a list, array, dataset, or other sequential data structure.


```{r example1, message=FALSE, warning=FALSE}
#explore the solution space
sol_space <- communities::solutions_space(g2, 
                                          n_trials = 100,
                                          met = "LV", 
                                          shuffle = FALSE)
#add quality check 
sol_space <- communities::quality_check(g, sol_space)

#plot
plots <- plot_sol_space(sol_space)

plots$pl2+theme(legend.position = 'none')+ggtitle('Frequency of solutions - ORDER BIAS')
plots$pl3+theme(legend.position = 'none')+ggtitle('Community size distribution  - ORDER BIAS')
 
```
In this case, only three distinct solutions were found, with one being significantly more frequent than the others. The ring of cliques represents an extreme case that clearly illustrates this issue. However, input ordering bias can occur with any network, not just in this specific example. For this reason, the shuffle parameter is set to TRUE by default, ensuring that the results are less dependent on the original input order.


## explore solutions space
```{r}



sol_space <- communities::solutions_space(g, 
                                          n_trials = 100,
                                          shuffle = TRUE,
                                          met = "IM", 
                                          IM.nb.trials = 1,
                                          confidence = 0.95,  
                                          comp_method = "ami")

sol_space <- communities::quality_check(g, sol_space)
plot_sol_space(sol_space)

df <- sol_space$data
M <- sol_space$M 
plot(make_clusters(g, M[,1]),g)
plot(make_clusters(g, M[,2]),g)
plot(make_clusters(g, M[,3]),g)
plot(make_clusters(g, M[,4]),g)


 
sm <- sol_space$simil
print(paste("non valid solutions: ",sum(df$valid==FALSE)))
print(paste("valid solutions: ",sum(df$valid==TRUE)))

#sol_space$data <- sol_space$data %>% filter(valid == TRUE)


sim_score_solutions <- rowMeans(sol_space$simil, na.rm = T)
print(sim_score_solutions)

overall_similarity<-mean(sol_space$simil, na.rm = T)
print(paste("Mean similarity score = ", overall_similarity))
hist(sol_space$simil)
 
```

 

  

```{r}
g <- communities::make_ring_of_cliques(num_cliques = 10,
                                       clique_size = 5, 
                                       add_center = T, 
                                       add_bridges = F)
ssp <- communities::solutions_space(g, n_trials = 20, met = "WT", confidence = .9) 
ssp <- communities::quality_check(g, ssp)

ssp$data
#ssp$M
plot_sol_space(ssp)
```


```{r}
communities::solutions_space(g, n_trials = 100, met = "WT",  comp_method = "ari", confidence = 0.95) %>% 
  plot_sol_space()

  

```

```{r}
ssp1 <- communities::solutions_space(g, n_trials = 20, met = "LD", resolution = 0.9, comp_method = 'ami')
ssp2 <- communities::solutions_space(g, n_trials = 20, met = "LD", resolution = 0.9, comp_method = 'ari') 

ssp1$data
ssp2$data

```


```{r}
plot(g)
ssp<-communities::solutions_space(g, n_trials = 100, met = "WT", comp_method = "ami") 
plot_sol_space(ssp)
sim_score_solutions <- rowMeans(ssp$simil, na.rm = T)
print(sim_score_solutions)

overall_similarity<-mean(ssp$simil, na.rm = T)
print(paste("Mean similarity score = ", overall_similarity))

```

```{r}
random_graph <- erdos.renyi.game(100, p=0.5, type = "gnp")
V(random_graph)$name <- 1:vcount(random_graph)


random_ssp <- communities::solutions_space(random_graph, n_trials = 50, met = "LD", 
                                           comp_method = "ami", confidence = .9)
random_ssp <- communities::quality_check(random_graph, random_ssp)

df<-random_ssp$data
print(paste("non valid solutions: ",sum(df$valid==FALSE)))
print(paste("valid solutions: ",sum(df$valid==TRUE)))
 
plot_sol_space(random_ssp)

sim_score_solutions <- rowMeans(random_ssp$simil, na.rm = T)
print(sim_score_solutions)

overall_similarity<-mean(random_ssp$simil, na.rm = T)
print(paste("Mean similarity score = ", overall_similarity))


```
 