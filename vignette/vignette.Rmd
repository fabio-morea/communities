
---
title: "Vignette: create a benchmark network and explore solution space"
author: "Fabio Morea"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{RIng of Cliques and solution space}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


# scope
This vignette illustrates the complete workflow of 'communities' library.

```{r libraries, message=FALSE, warning=FALSE}
# required packages
library(igraph)
library(communities)

# additional packages to improve workflow and figures
library(tidyverse)
library(gridExtra)
library(patchwork)
```


# Benchmark networks
We start by building a simple benchmark network: a Ring of Cliques (RC) composed of 5 cliques of 6 nodes each. In such a simple case communities are easily identified by any community detection algorithm.
 

```{r example1, message=FALSE, warning=FALSE}
RC_simple <- communities::make_ring_of_cliques(num_cliques = 5,
                                       clique_size = 5, 
                                       add_center = F, 
                                       add_bridges = F)
partition <- igraph::cluster_louvain(RC_simple)

plot(partition, RC_simple)
 
 
```

However, RC can be used to produce a network in which community boundaries are less clear. 

```{r example2, message=FALSE, warning=FALSE}
RC_c <- communities::make_ring_of_cliques(num_cliques = 4,
                                       clique_size = 6, 
                                       add_center = T, 
                                       add_bridges = F)

node_positions <- igraph::layout.fruchterman.reingold(RC_c)
partition <- igraph::cluster_louvain(RC_c)
plot(partition, RC_c, layout = node_positions)
 

```
The central node can either belong to any of the cliques or be considered its own single-node community. This presents a challenge for both algorithms and human analysts alike, as it creates ambiguity in community assignment. Consequently, we can anticipate five equally probable solutions, where the central node is equally likely to be associated with any of the cliques.

```{r example1, message=FALSE, warning=FALSE}
RC_b <- communities::make_ring_of_cliques(num_cliques = 4,
                                       clique_size = 6, 
                                       add_center = F, 
                                       add_bridges = T)

node_positions <- igraph::layout.fruchterman.reingold(RC_b)
partition <- igraph::cluster_louvain(RC_b)
plot(partition, RC_b, layout = node_positions)
#explore the solution space
sol_space <- communities::solutions_space(RC_b, 
                                          n_trials = 1000,
                                          met = "LV", 
                                          tau = .95)
sol_space <- communities::quality_check(RC_b, sol_space)
plots<-communities::plot_sol_space(sol_space)
plots$pl2
plots$pl3
communities::plot_solutions(RC_b, sol_space, add_node_labels = F, add_prob_labels = TRUE)
 
communities::plot_sol_space_evolution(sol_space, confidence = .90) 
        
```


```{r}

sol_space <- communities::solutions_space(RC_c, 
                                          n_trials = 1000,
                                          met = "LV", 
                                          tau = .95)
sol_space <- communities::quality_check(RC_c, sol_space)
plots<-communities::plot_sol_space(sol_space)
plots$pl2
plots$pl3
 

communities::plot_sol_space_evolution(sol_space, confidence = .90) 

```



```{r}
plot_solutions <- function(g, sol_space,
                           device = "screen", 
                           filename = NULL, 
                           width = 1600, height = 1600, res = 300) {
  
  # If device is PNG, open the PNG file
  if (device == "png" && !is.null(filename)) {
    png(filename, width = width, height = height, res = res)  
  }
  
  # Set up the plotting area
  par(mfrow = c(ceiling(sqrt(ns)), ceiling(sqrt(ns))),  # Grid layout
      mar = c(1.0, 0.1, 2.0, 0.1),  # Minimal margins: bottom, left, top, right
      oma = c(0, 0, 0, 0))        # No outer margins

  # Plot each solution
  node_positions <- igraph::layout.fruchterman.reingold(g)
  ns <- nrow(sol_space$data)
  
  for (i in 1:ns) {
    # Extract membership information
    membership_i <- sol_space$M[, i]
    
    # Plot the graph highlighting the i-th solution  
    plot(RC_c, 
         layout = node_positions,
         vertex.size = 30,
         vertex.color = "white",        
         mark.groups = split(1:vcount(g), membership_i),          
         mark.col = rgb(0.5, 0.5, 0.5, alpha = 0.1),   
         mark.border = 'red',              
         main = paste("Solution", i)
    )
  }

  # If PNG device was opened, close it
  if (device == "png") {
    dev.off()
  }

  # Reset to default plotting layout (if plotting to the screen)
  par(mfrow = c(1, 1), mar = c(5, 4, 4, 2) + 0.1)
}

# ---- Step 1: Plot on screen ----
plot_solutions(RC_c, sol_space)  # Plot to the screen

# ---- Step 2: Save to PNG file ----
plot_solutions(RC_c, sol_space, 
               device = "png", 
               filename = "solution_plots.png")
```



#add quality check 
sol_space <- communities::quality_check(g, sol_space)

#plot
plots <- plot_sol_space(sol_space)

plots$pl2+theme(legend.position = 'none')+ggtitle('Frequency of solutions')
plots$pl3+theme(legend.position = 'none')+ggtitle('Community size distribution')


partition_i = sol_space$M[,i]
plot(partition, RC_c, layout = node_positions)
 
```
The solution space shows that there are 6 solutions, they are all equally likely (the confidence intervals are overlapping).

## input ordering bias
In the example above, the network was shuffled before each run of the community detection algorithm to help mitigate input ordering bias. To highlight the importance of this, we can repeat the experiment with the 'shuffle' parameter set to FALSE. In this case, community detection will be performed on the network exactly as it was provided, which is influenced by the order in which nodes and edges are sorted in the original data. Although in theory this should not impact the results (since graphs are inherently unordered mathematical objects), it does. This is because the software representation of networks is inherently ordered—whether in the form of a list, array, dataset, or other sequential data structure.


```{r example1, message=FALSE, warning=FALSE}
#explore the solution space
sol_space <- communities::solutions_space(g2, 
                                          n_trials = 100,
                                          met = "LV", 
                                          shuffle = FALSE)
#add quality check 
sol_space <- communities::quality_check(g, sol_space)

#plot
plots <- plot_sol_space(sol_space)

plots$pl2+theme(legend.position = 'none')+ggtitle('Frequency of solutions - ORDER BIAS')
plots$pl3+theme(legend.position = 'none')+ggtitle('Community size distribution  - ORDER BIAS')
 
```
In this case, only three distinct solutions were found, with one being significantly more frequent than the others. The ring of cliques represents an extreme case that clearly illustrates this issue. However, input ordering bias can occur with any network, not just in this specific example. For this reason, the shuffle parameter is set to TRUE by default, ensuring that the results are less dependent on the original input order.

However, RC can be used to produce a network in which community boundaries are less clear. 

```{r example2, message=FALSE, warning=FALSE}
RC_c <- communities::make_ring_of_cliques(num_cliques = 4,
                                       clique_size = 6, 
                                       add_center = T, 
                                       add_bridges = F)

partition <- igraph::cluster_louvain(RC_c)

node_positions <- igraph::layout.fruchterman.reingold(RC_c)
plot(partition, RC_c, layout = node_positions)

```
The central node can either belong to any of the cliques or be considered its own single-node community. This presents a challenge for both algorithms and human analysts alike, as it creates ambiguity in community assignment. Consequently, we can anticipate five equally probable solutions, where the central node is equally likely to be associated with any of the cliques.

```{r example1, message=FALSE, warning=FALSE}
#explore the solution space
sol_space <- communities::solutions_space(RC_c, 
                                          n_trials = 100,
                                          met = "LV")
sol_space <- communities::quality_check(RC_c, sol_space)

plots<-communities::plot_sol_space(sol_space)

p2<-plots$pl2+ theme(legend.position = 'none', aspect.ratio = 1)
p3<-plots$pl3+ theme(legend.position = 'none', aspect.ratio = 1)

grid.arrange(p2,p3, ncol = 2)




```

```{r}

communities::plot_all_solutions(RC_c, sol_space)   
 
```


## input ordering bias
In the example above, the network was shuffled before each run of the community detection algorithm to help mitigate input ordering bias. To highlight the importance of this, we can repeat the experiment with the 'shuffle' parameter set to FALSE. In this case, community detection will be performed on the network exactly as it was provided, which is influenced by the order in which nodes and edges are sorted in the original data. Although in theory this should not impact the results (since graphs are inherently unordered mathematical objects), it does. This is because the software representation of networks is inherently ordered—whether in the form of a list, array, dataset, or other sequential data structure.


```{r example1, message=FALSE, warning=FALSE}
#explore the solution space
sol_space_biased <- communities::solutions_space(RC_c, 
                                          n_trials = 100,
                                          met = "LV", 
                                          shuffle = FALSE)
#add quality check 
sol_space_biased <- communities::quality_check(RC_c, sol_space_biased)

#plot
plots_biased <- plot_sol_space(sol_space_biased)

p2b<-plots_biased$pl2+theme(legend.position = 'none')
p3b<-plots_biased$pl3+theme(legend.position = 'none')

communities::plot_all_solutions(RC_c, sol_space_biased) 

grid.arrange(p2b,p3b, ncol = 2)


```
In this case, only three distinct solutions were found, with one being significantly more frequent than the others. The ring of cliques represents an extreme case that clearly illustrates this issue. However, input ordering bias can occur with any network, not just in this specific example. For this reason, the shuffle parameter is set to TRUE by default, ensuring that the results are less dependent on the original input order.

# consensus community detection on unbiased solutions
```{r}

sol_space <- communities::solutions_space(RC_c, 
                                          n_trials = 100,
                                          met = "LV")
sol_space <- communities::quality_check(RC_c, sol_space)
 
D <- communities::co_occurrence(sol_space)
 
        
comms <- communities::consensus_communities(D, p =.8)
        
        #aggregate singletons in community 0
        #comms$community[ comms$community_size == 1] <- 0
        #
  
        
nc <- max(comms$cons_comm_label)
V(RC_c)$community <- comms$cons_comm_label
V(RC_c)$gamma <- comms$gamma %>% round(2)

node_positions <- igraph::layout.fruchterman.reingold(RC_c)


par(mfrow = c(1,2),  # Grid layout
        mar = c(1.0, 1.0, 2.0, 1.0),  #  inner margins: bottom, left, top, right
        oma = c(0, 1.0, 0, 1.00))          #  outer margins: bottom, left, top, right

plot(RC_c, 
     layout = node_positions,
     vertex.size = 30,
     vertex.color = "white",
     vertex.label = paste("C",V(RC_c)$community),
     vertex.label.cex = 0.5,   
     vertex.label.color = "black",  
     vertex.label.family = "sans",  
     mark.groups = split(1:vcount(RC_c), V(RC_c)$community ),          
     mark.col = rgb(0.5, 0.5, 0.5, alpha = 0.1),   
     mark.border = 'red',              
     main = "membership"
     )
     

plot(RC_c, 
     layout = node_positions,
     vertex.size = 30,
     vertex.label = V(RC_c)$gamma ,
     vertex.label.cex = 0.5,   
     vertex.label.color = "black",  
     vertex.label.family = "sans",  
     vertex.color = if_else(V(RC_c)$gamma > 0.5, "yellow", "lightgreen"),
     mark.groups = split(1:vcount(RC_c), V(RC_c)$community ),          
     mark.col = rgb(0.5, 0.5, 0.5, alpha = 0.1),   
     mark.border = 'red',              
     main = "uncertainty"
     )
par(mfrow = c(1, 1), mar = c(5, 4, 4, 2) + 0.1, oma = c(0,0,0,0))
 
 

```

# testing solution space params
In this case we set a maximum number of trials at 500, and tau = 0.90 ie we want to stop searching for new solutions when the probability of a stable solution space is .90

```{r}
sol_space <- communities::solutions_space(RC_c, 
                                          n_trials = 500,
                                          tau = 0.9,
                                          met = "LV")
logdata<-sol_space$log
last <- logdata %>% tail(1) 
t = last$a + last$b -2
ns = last$s
p_stable = (t-ns)/(t+1)
p_stable
```
something different occurs when there are multiple solutions
If we set tmax = 100, the probability of a complete solution space is low, around 0.75
set higher tmax and exit when p = 0.90
ie at t = 210

```{r}

RC_cb <- communities::make_ring_of_cliques(num_cliques = 5,
                                       clique_size = 5, 
                                       add_center = T, 
                                       add_bridges = T)

plot(RC_cb)

sol_space <- communities::solutions_space(RC_cb, 
                                          n_trials = 200,
                                          tau = 0.9,
                                          met = "LV")

logdata<-sol_space$log
last <- logdata %>% tail(1) 
t = last$a + last$b -2
ns = last$s
p_stable = (t-ns)/(t+1)
p_stable

sol_space <- quality_check(RC_cb, sol_space )
plot_sol_space(sol_space )
```

 
   
 